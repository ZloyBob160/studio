import type { ChatCompletion } from '@/lib/types';

const REQUIRED_ENV_VARS = [
  'CONFLUENCE_BASE_URL',
  'CONFLUENCE_SPACE_KEY',
  'CONFLUENCE_EMAIL',
  'CONFLUENCE_API_TOKEN',
] as const;

type RequiredConfigKey = (typeof REQUIRED_ENV_VARS)[number];

type ConfluenceConfig = {
  baseUrl: string;
  spaceKey: string;
  email: string;
  apiToken: string;
  parentPageId?: string;
};

type ConfluenceContent = {
  id: string;
  title: string;
  version?: { number: number };
  _links?: { webui?: string };
};

type PagePayload = {
  type: 'page';
  title: string;
  space: { key: string };
  body: {
    storage: {
      value: string;
      representation: 'storage';
    };
  };
  ancestors?: Array<{ id: string }>;
};

export type PublishResult = {
  url: string;
  action: 'created' | 'updated';
  title: string;
};

export async function publishDocumentsToConfluence({
  documents,
  conversationTitle,
}: {
  documents: ChatCompletion;
  conversationTitle: string;
}): Promise<PublishResult> {
  const config = getConfig();
  const title = sanitizeTitle(conversationTitle);
  const html = buildConfluenceHtml(documents);
  const payload = buildPagePayload(title, html, config);

  const existing = await findPageByTitle(title, config);
  const page = existing
    ? await updatePage(existing, payload, config)
    : await createPage(payload, config);

  const url = buildPageUrl(page, config);

  return {
    url,
    action: existing ? 'updated' : 'created',
    title,
  };
}

function getConfig(): ConfluenceConfig {
  const missing: RequiredConfigKey[] = [];
  const env = process.env;
  for (const key of REQUIRED_ENV_VARS) {
    if (!env[key] || !env[key]!.trim()) {
      missing.push(key);
    }
  }

  if (missing.length) {
    throw new Error(
      `Missing Confluence configuration: ${missing.join(', ')}. ` +
        'Please set the environment variables before exporting documents.'
    );
  }

  return {
    baseUrl: trimTrailingSlash(env.CONFLUENCE_BASE_URL!.trim()),
    spaceKey: env.CONFLUENCE_SPACE_KEY!.trim(),
    email: env.CONFLUENCE_EMAIL!.trim(),
    apiToken: env.CONFLUENCE_API_TOKEN!.trim(),
    parentPageId: env.CONFLUENCE_PARENT_PAGE_ID?.trim(),
  };
}

function sanitizeTitle(title: string): string {
  const fallback = 'AnalystAI Requirements Document';
  const trimmed = title?.trim();
  if (!trimmed) return fallback;
  return trimmed.length > 120 ? `${trimmed.slice(0, 117)}...` : trimmed;
}

function buildConfluenceHtml(documents: ChatCompletion): string {
  const { requirements, artifacts } = documents;
  const orderedSections: Array<{ heading: string; content: string }> = [
    { heading: 'Goal', content: requirements.goal },
    { heading: 'Description', content: requirements.description },
    { heading: 'Scope', content: requirements.scope },
    { heading: 'Business Rules', content: requirements.businessRules },
    { heading: 'KPIs', content: requirements.kpis },
    { heading: 'Use Cases', content: artifacts.useCases },
    { heading: 'User Stories', content: artifacts.userStories },
    { heading: 'Process Diagrams', content: artifacts.processDiagrams },
    { heading: 'Leading Indicators', content: artifacts.leadingIndicators },
  ];

  const formattedSections = orderedSections
    .map(
      section => `
        <h2>${escapeHtml(section.heading)}</h2>
        ${formatRichText(section.content)}
      `
    )
    .join('');

  const generatedAt = new Date().toISOString();

  return `
    <p><strong>Generated by AnalystAI on:</strong> ${generatedAt}</p>
    ${formattedSections}
  `;
}

function formatRichText(value: string): string {
  const lines = value
    .split('\n')
    .map(line => line.trim())
    .filter(Boolean);

  if (!lines.length) {
    return '<p>No content provided.</p>';
  }

  return lines.map(line => `<p>${escapeHtml(line)}</p>`).join('');
}

function escapeHtml(value: string): string {
  return value
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;')
    .replace(/\*/g, '&#42;');
}

function buildPagePayload(title: string, html: string, config: ConfluenceConfig): PagePayload {
  const payload: PagePayload = {
    type: 'page',
    title,
    space: { key: config.spaceKey },
    body: {
      storage: {
        value: `<div>${html}</div>`,
        representation: 'storage',
      },
    },
  };

  if (config.parentPageId) {
    payload.ancestors = [{ id: config.parentPageId }];
  }

  return payload;
}

async function findPageByTitle(
  title: string,
  config: ConfluenceConfig
): Promise<ConfluenceContent | undefined> {
  const params = new URLSearchParams({
    title,
    spaceKey: config.spaceKey,
    expand: 'version',
  });

  const result = await confluenceRequest<{ results?: ConfluenceContent[] }>(
    config,
    `/rest/api/content?${params.toString()}`,
    {
      method: 'GET',
    }
  );

  return result.results?.[0];
}

async function createPage(payload: PagePayload, config: ConfluenceConfig) {
  return confluenceRequest<ConfluenceContent>(config, '/rest/api/content', {
    method: 'POST',
    body: JSON.stringify(payload),
  });
}

async function updatePage(
  page: ConfluenceContent,
  payload: PagePayload,
  config: ConfluenceConfig
) {
  const versionNumber = (page.version?.number ?? 0) + 1;
  return confluenceRequest<ConfluenceContent>(config, `/rest/api/content/${page.id}`, {
    method: 'PUT',
    body: JSON.stringify({
      ...payload,
      id: page.id,
      version: { number: versionNumber },
    }),
  });
}

function buildPageUrl(page: ConfluenceContent, config: ConfluenceConfig): string {
  const base = config.baseUrl;
  if (page._links?.webui) {
    return `${base}${page._links.webui}`;
  }
  return `${base}/spaces/${config.spaceKey}/pages/${page.id}`;
}

async function confluenceRequest<T>(
  config: ConfluenceConfig,
  path: string,
  init: RequestInit
): Promise<T> {
  const auth = Buffer.from(`${config.email}:${config.apiToken}`).toString('base64');
  const response = await fetch(`${config.baseUrl}${path}`, {
    ...init,
    headers: {
      'Content-Type': 'application/json',
      Accept: 'application/json',
      Authorization: `Basic ${auth}`,
      ...(init.headers || {}),
    },
    cache: 'no-store',
  });

  const rawBody = await response.text();
  let data: any = undefined;
  if (rawBody) {
    try {
      data = JSON.parse(rawBody);
    } catch (error) {
      data = rawBody;
    }
  }

  if (!response.ok) {
    const message =
      typeof data === 'string'
        ? `Confluence request failed (${response.status}).`
        : data?.message || data?.errors?.[0]?.message || `Confluence request failed (${response.status}).`;
    throw new Error(message);
  }

  return data as T;
}

function trimTrailingSlash(value: string): string {
  return value.endsWith('/') ? value.slice(0, -1) : value;
}
